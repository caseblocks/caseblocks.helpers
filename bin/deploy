#!/bin/bash

# Deploy script for caseblocks.helpers
# This script bumps the version, creates a git tag, and pushes to GitHub

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Get the script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$PROJECT_ROOT"

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}Error: Not in a git repository${NC}"
    exit 1
fi

# Get current branch
CURRENT_BRANCH=$(git branch --show-current)
echo -e "${GREEN}Current branch: ${CURRENT_BRANCH}${NC}"

# Check for uncommitted changes (staged, unstaged, and untracked)
HAS_UNCOMMITTED=false
HAS_STAGED=false
HAS_UNSTAGED=false
HAS_UNTRACKED=false

# Check for staged changes
if ! git diff --cached --quiet; then
    HAS_STAGED=true
    HAS_UNCOMMITTED=true
fi

# Check for unstaged changes
if ! git diff --quiet; then
    HAS_UNSTAGED=true
    HAS_UNCOMMITTED=true
fi

# Check for untracked files
if [ -n "$(git ls-files --others --exclude-standard)" ]; then
    HAS_UNTRACKED=true
    HAS_UNCOMMITTED=true
fi

# Report uncommitted changes
if [ "$HAS_UNCOMMITTED" = true ]; then
    echo -e "${YELLOW}⚠ Uncommitted changes detected:${NC}"
    if [ "$HAS_STAGED" = true ]; then
        echo -e "  ${YELLOW}• Staged changes${NC}"
        git diff --cached --stat
    fi
    if [ "$HAS_UNSTAGED" = true ]; then
        echo -e "  ${YELLOW}• Unstaged changes${NC}"
        git diff --stat
    fi
    if [ "$HAS_UNTRACKED" = true ]; then
        echo -e "  ${YELLOW}• Untracked files${NC}"
        git ls-files --others --exclude-standard
    fi
    echo ""
    read -p "Continue with uncommitted changes? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Please commit or stash your changes before deploying.${NC}"
        exit 1
    fi
else
    echo -e "${GREEN}✓ No uncommitted changes${NC}"
fi

# Fetch latest from remote to check for remote changes
echo -e "${GREEN}Fetching latest from remote...${NC}"
git fetch origin "$CURRENT_BRANCH" || {
    echo -e "${RED}Error: Failed to fetch from remote${NC}"
    exit 1
}

# Check if local branch is behind remote
LOCAL_COMMIT=$(git rev-parse HEAD)
REMOTE_COMMIT=$(git rev-parse "origin/$CURRENT_BRANCH" 2>/dev/null || echo "")

if [ -z "$REMOTE_COMMIT" ]; then
    echo -e "${YELLOW}Warning: Remote branch 'origin/$CURRENT_BRANCH' not found${NC}"
    read -p "Continue anyway? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
elif [ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]; then
    # Check if we're behind
    if git merge-base --is-ancestor "$LOCAL_COMMIT" "$REMOTE_COMMIT"; then
        echo -e "${YELLOW}⚠ Your local branch is behind the remote${NC}"
        echo -e "${YELLOW}Remote has commits you don't have locally:${NC}"
        git log --oneline "$LOCAL_COMMIT..$REMOTE_COMMIT"
        echo ""
        read -p "Pull and merge remote changes? (Y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            echo -e "${GREEN}Pulling latest changes...${NC}"
            git pull origin "$CURRENT_BRANCH" || {
                echo -e "${RED}Error: Failed to pull changes. You may need to resolve conflicts.${NC}"
                exit 1
            }
        else
            echo -e "${YELLOW}Deployment cancelled. Please pull changes first.${NC}"
            exit 1
        fi
    else
        # We're ahead or diverged
        if git merge-base --is-ancestor "$REMOTE_COMMIT" "$LOCAL_COMMIT"; then
            echo -e "${GREEN}✓ Local branch is ahead of remote (will push new commits)${NC}"
        else
            echo -e "${RED}⚠ Warning: Local and remote branches have diverged${NC}"
            echo -e "${YELLOW}Local commits not in remote:${NC}"
            git log --oneline "$REMOTE_COMMIT..$LOCAL_COMMIT"
            echo -e "${YELLOW}Remote commits not in local:${NC}"
            git log --oneline "$LOCAL_COMMIT..$REMOTE_COMMIT"
            echo ""
            read -p "Continue anyway? This may cause conflicts. (y/N) " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo -e "${YELLOW}Deployment cancelled. Please sync branches first.${NC}"
                exit 1
            fi
        fi
    fi
else
    echo -e "${GREEN}✓ Local branch is up to date with remote${NC}"
fi

# Get the latest version tag
LATEST_TAG=$(git tag --sort=-version:refname | head -1)

if [ -z "$LATEST_TAG" ]; then
    # No tags exist, start with v0.1.0
    CURRENT_VERSION="0.0.0"
    echo -e "${YELLOW}No existing tags found. Starting with v0.1.0${NC}"
else
    # Remove 'v' prefix if present
    CURRENT_VERSION="${LATEST_TAG#v}"
    echo -e "${GREEN}Latest version: v${CURRENT_VERSION}${NC}"
fi

# Parse version components
IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
MAJOR=${VERSION_PARTS[0]:-0}
MINOR=${VERSION_PARTS[1]:-0}
PATCH=${VERSION_PARTS[2]:-0}

# Determine version bump type
if [ -z "$1" ]; then
    echo -e "${YELLOW}Select version bump type:${NC}"
    echo "1) Patch (${MAJOR}.${MINOR}.$((PATCH + 1)))"
    echo "2) Minor (${MAJOR}.$((MINOR + 1)).0)"
    echo "3) Major ($((MAJOR + 1)).0.0)"
    read -p "Enter choice [1-3] (default: 1): " choice
    choice=${choice:-1}
else
    case "$1" in
        patch|p|1)
            choice=1
            ;;
        minor|m|2)
            choice=2
            ;;
        major|M|3)
            choice=3
            ;;
        *)
            echo -e "${RED}Invalid version type: $1${NC}"
            echo "Usage: $0 [patch|minor|major]"
            exit 1
            ;;
    esac
fi

# Calculate new version
case $choice in
    1)
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
        ;;
    2)
        NEW_MINOR=$((MINOR + 1))
        NEW_VERSION="${MAJOR}.${NEW_MINOR}.0"
        ;;
    3)
        NEW_MAJOR=$((MAJOR + 1))
        NEW_VERSION="${NEW_MAJOR}.0.0"
        ;;
    *)
        echo -e "${RED}Invalid choice${NC}"
        exit 1
        ;;
esac

NEW_TAG="v${NEW_VERSION}"

# Confirm before proceeding
echo -e "${YELLOW}Ready to deploy:${NC}"
echo "  Current version: v${CURRENT_VERSION}"
echo "  New version: ${NEW_TAG}"
echo "  Branch: ${CURRENT_BRANCH}"
read -p "Continue? (y/N) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo -e "${YELLOW}Deployment cancelled${NC}"
    exit 0
fi

# Create git tag
echo -e "${GREEN}Creating tag ${NEW_TAG}...${NC}"
git tag -a "${NEW_TAG}" -m "Release ${NEW_TAG}" || {
    echo -e "${RED}Error: Failed to create tag${NC}"
    exit 1
}

# Push changes and tags
echo -e "${GREEN}Pushing changes to origin...${NC}"
git push origin "$CURRENT_BRANCH" || {
    echo -e "${RED}Error: Failed to push changes${NC}"
    exit 1
}

echo -e "${GREEN}Pushing tags to origin...${NC}"
git push origin "${NEW_TAG}" || {
    echo -e "${RED}Error: Failed to push tag${NC}"
    exit 1
}

echo -e "${GREEN}✓ Successfully deployed ${NEW_TAG}${NC}"
echo -e "${GREEN}Version ${NEW_TAG} has been tagged and pushed to GitHub${NC}"
